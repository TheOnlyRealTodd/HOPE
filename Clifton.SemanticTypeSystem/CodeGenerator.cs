using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Clifton.Assertions;
using Clifton.ExtensionMethods;

using Clifton.SemanticTypeSystem.Interfaces;

namespace Clifton.SemanticTypeSystem
{
	public static class CodeGenerator
	{
		// Yes, I know string isn't really a value type.
		static string[] valueTypes = new string[] {
				"bool", "byte", "char", "decimal", "double", "float", "int", "long", "sbyte", "short", "uint", "ulong", "ushort", "string"};

		/// <summary>
		/// Yucky brute force coding.
		/// </summary>
		public static string Generate(Dictionary<string, SemanticType> SemanticTypes)
		{
			StringBuilder sb = new StringBuilder();
			sb.AppendLine("// This code has been generated by the Semantic Type System.");
			sb.AppendLine("using System;");
			sb.AppendLine("using System.Drawing;");
			sb.AppendLine("using System.Collections.Generic;");
			sb.AppendLine("using Clifton.SemanticTypeSystem.Interfaces;");
			sb.AppendLine("using Clifton.Receptor.Interfaces;");
			sb.AppendLine();
			sb.AppendLine("namespace SemanticTypes");
			sb.AppendLine("{");

			foreach (SemanticType st in SemanticTypes.Values)
			{
				// Classes
				SemanticTypeStruct ststruct = st.Decl.OfType;
				sb.AppendLine("\t//Implements ISemanticType as the object type and requires Initialize().");
				sb.AppendLine("\tpublic class " + ststruct.DeclTypeName + " : ISemanticType");
				sb.AppendLine("\t{");
				List<string> initializers = new List<string>();

				// Native type properties...
				if (ststruct.HasNativeTypes)
				{
					sb.AppendLine("\t\t//Native types.");
					foreach (NativeType ntype in ststruct.NativeTypes)
					{
						sb.AppendLine("\t\tpublic " + ntype.ImplementingType + " " + ntype.Name + " {get; set;}");
						
						// TODO: Some types, like Action, don't have parameterless constructors.  Need to deal with that.
						/*
						// If it's an object (not a value type), instantiate the thing.
						if (!IsValueType(ntype.ImplementingType))
						{
							// Except if it's an interface
							// TODO: Fix this by actually testing if it's an interface type!
							if (ntype.ImplementingType.StartsWith("I"))
							{
								initializers.Add("\t\t\t" + ntype.Name + " = null;");
							}
							else
							{
								initializers.Add("\t\t\t" + ntype.Name + " = new " + ntype.ImplementingType + "();");
							}
						}
						*/
					}
				}

				if (ststruct.HasSemanticTypes)
				{
					sb.AppendLine("\t\t//Semantic types.");
					foreach (SemanticElement selem in ststruct.SemanticElements)
					{
						sb.AppendLine("\t\tpublic dynamic " + selem.Name + " {get; set;}");
					}
				}

				if (ststruct.HasChildTypes) sb.AppendLine();

				// Class constructor...
				// Workaround for the fact that interfaces can't be implemented with static methods.
				sb.AppendLine("\t\t//Constructor.  Typically called by reflection.");
				sb.AppendLine("\t\tpublic " + ststruct.DeclTypeName + "() {}");
				sb.AppendLine();


				// ICreate.Create:
				sb.AppendLine("\t\t//Implements ICreate.");
				sb.AppendLine("\t\tpublic void Initialize(ISemanticTypeSystem sts)");
				sb.AppendLine("\t\t{");

				if (ststruct.HasNativeTypes)
				{
					// Property initializers for native types.
					// If the struct has a native type which is implemented by the decl, initialize the value.
					sb.AppendLine("\t\t\t//Native type initializers.");
					InitializeNativeTypes(st, ststruct.NativeTypes, sb);
				}

				if (ststruct.HasSemanticTypes)
				{
					foreach (SemanticElement selem in ststruct.SemanticElements)
					{
						// ST to create, and this, as the parent.
						sb.AppendLine("\t\t\t" + selem.Name + " = sts.Create(\"" + selem.Name + "\", this);");
					}
				}

				sb.AppendLine("\t\t\t//Additional semantic type initializers.");
				// Property initializers for semantic types.
				// If the struct has a semantic type which has properties implemented in the decl, initialize the value.
				if (ststruct.HasSemanticTypes)
				{
					foreach (SemanticElement selem in ststruct.SemanticElements)
					{
						Assert.ErrorMessage = "Type" + selem.Name + " does not have a structure defined.";
						SemanticType stChild = SemanticTypes.Single(s => s.Value.Struct.DeclTypeName == selem.Name).Value;
						InitializeNativeTypes(st, stChild.Struct.NativeTypes, sb, selem.Name);
					}
				}

				// emit object initializers.
				if (initializers.Count > 0)
				{
					sb.AppendLine("\t\t\t//Object initializers.");
					initializers.ForEach(t=>sb.AppendLine(t));
				}

				sb.AppendLine("\t\t}");
				sb.AppendLine("\t}");
				sb.AppendLine();
			}

			sb.AppendLine("}");

			return sb.ToString();
		}

		/// <summary>
		/// Initializes the native types of a semantic type to the attribute values specified in the markup.
		/// TODO: This needs to be recursive and also to parse dotted notation when drilling into multiple levels of types.
		/// </summary>
		public static void InitializeNativeTypes(SemanticType st, List<INativeType> nativeTypes, StringBuilder sb, string prefix="")
		{
			foreach (NativeType ntype in nativeTypes)
			{
				// Attribute may not be initialized, in which case it defaults to the native implementation's default.
				st.Decl.AttributeValues.Find(t => t.Name == ntype.Name).IfNotNull(t =>
				{
					string qualifiedName = (prefix.IsEmpty() ? t.Name : prefix + "." + t.Name);

					if (ntype.ImplementingType == "string")
					{
						sb.AppendLine("\t\t\t" + qualifiedName + " = \"" + t.Value + "\";");
					}
					else
					{
						sb.AppendLine("\t\t\t" + qualifiedName + " = " + t.Value + ";");
					}
				});
			}
		}

		public static bool IsValueType(string name)
		{
			return valueTypes.Contains(name);
		}
	}
}
